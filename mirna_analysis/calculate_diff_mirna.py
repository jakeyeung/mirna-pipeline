#!/usr/local/bin/python2.7
# encoding: utf-8
'''
Description:

Classes and methods:

@author:     jakeyeung

@lab:  2014 Laboratory for Advanced Genome Analysis.

@license:    Apache License 2.0

@contact:    jakeyeung@gmail
        :    github.com/jakeyeung
@deffield    updated: None yet
'''

import sys
import os
import csv

from optparse import OptionParser

from utils import AnnotatedReads, list_utils

__all__ = []
__version__ = 0.1
__date__ = 'May 20 2014'
__updated__ = ''

DEBUG = 0
TESTRUN = 0
PROFILE = 0

def index_tpm_file(tpm_file):
    '''
    # Index to dic with annotation as dickey
    Rationale for using annotation as dickey:
        microRNAs often have multiple locations in the genome.
        The genome locations to which miRNAs are mapped are actually
        not too reliable.
        All we can do is to collect common microRNAs and group them
        But we will keep track of the genome locations if we want
        to do downstream DNA mutation analysis
    Subdics contain chr, start, end, strand, reads, TPM, annotations

    Output dic will be of form:
        {annot: {loc:[chromo1:start1:end1:strand1], tpm:[reads_from_1]. tpm_sum:sum of tpm}}
        The lists in subdic should be ordered such that they can be
        iterated in parallel
    '''
    outdic = {}
    with tpm_file:
        for row in tpm_file.reader:
            # get row info
            chromo = row[tpm_file.header.index('chr')]
            start = int(row[tpm_file.header.index('start')])
            end = int(row[tpm_file.header.index('end')])
            strand = row[tpm_file.header.index('strand')]
            #reads = int(row[tpm_file.header.index('strand')]) #use tpm instead of reads
            tpm = float(row[tpm_file.header.index('TPM')])
            annot = row[tpm_file.header.index('annotations')]
            if annot not in outdic:
                #create subdics if annot not yet initialized
                outdic[annot] = {'locs':[], 'tpms':[], 'tpm_sum':0.}
            # assumes subdics are now initialized
            # fill subdics with row info
            location = '%s:%s:%s:%s' %(chromo, start, end, strand)
            outdic[annot]['locs'].append(location)
            outdic[annot]['tpms'].append(tpm)
            outdic[annot]['tpm_sum'] += tpm
    return outdic

def main(argv=None):
    '''Command line options.'''

    program_name = os.path.basename(sys.argv[0])
    program_version = "v0.1"
    program_build_date = "%s" % __updated__

    program_version_string = '%%prog %s (%s)' % (program_version, program_build_date)
    #program_usage = '''usage: spam two eggs''' # optional - will be autogenerated by optparse
    program_longdesc = '''''' # optional - give further explanation about what the program does
    program_license = "Copyright 2014 Jake Yeung (Laboratory for Advanced Genome Analysis)                                            \
                Licensed under the Apache License 2.0\nhttp://www.apache.org/licenses/LICENSE-2.0"

    if argv is None:
        argv = sys.argv[1:]

    # setup option parser
    parser = OptionParser(version=program_version_string, epilog=program_longdesc, description=program_license)
    parser.add_option("-t", "--tumour", dest="tumourfile", help="set input path for tumour [default: %default]", metavar="FILE")
    parser.add_option("-b", "--benign", dest="benignfile", help="set input path for benign [default: %default]", metavar="FILE")
    parser.add_option("-o", "--out", dest="outfile", help="set output path [default: %default]", metavar="FILE")
    parser.add_option("-v", "--verbose", dest="verbose", action="count", help="set verbosity level [default: %default]")

    # set defaults
    parser.set_defaults(outfile="./out.txt", infile="./in.txt")

    # process options
    (opts, args) = parser.parse_args(argv)

    if opts.verbose > 0:
        print("verbosity level = %d" % opts.verbose)
    if opts.infile:
        print("tumourfile = %s" % opts.tumourfile)
    if opts.outfile:
        print("benignfile = %s" % opts.benignfile)
    if opts.outfile:
        print("outfile = %s" % opts.outfile)

    # MAIN BODY #
    tumour_tpm = AnnotatedReads.AnnotatedReads(opts.tumourfile)
    benign_tpm = AnnotatedReads.AnnotatedReads(opts.benignfile)

    benign_dic = index_tpm_file(benign_tpm)
    tumour_dic = index_tpm_file(tumour_tpm)

    #init outfile
    outfile = open(opts.outfile, 'wb')
    outwriter = csv.writer(outfile, delimiter='\t')
    '''
    # write header containing:
    [mirna(annotations), tpm_benign, tpm_tumour, fold_change,
    locations_benign,
    locations_benign_tpms, locations_tumour, locations_tumour_tpms]
    '''
    writeheader = ['mirna',
                   'tpm_benign_sum',
                   'tpm_tumour_sum',
                   'tpm_sum_fold_change']
    outwriter.writerow(writeheader)

    for annot in benign_dic.keys():
        try:
            tumour_tpm_sum = tumour_dic[annot]['tpm_sum']
        except KeyError:
            continue
        #calculate fold change, get locations and tpms lists
        benign_tpm_sum = benign_dic[annot]['tpm_sum']
        fold_change = float(tumour_tpm_sum) / benign_tpm_sum
        # write row, matching to writeheader
        writerow = [annot,
                    benign_tpm_sum,
                    tumour_tpm_sum,
                    fold_change]
        outwriter.writerow(writerow)
    outfile.close()

if __name__ == "__main__":
    if DEBUG:
        sys.argv.append("-h")
    if TESTRUN:
        import doctest
        doctest.testmod()
    if PROFILE:
        import cProfile
        import pstats
        profile_filename = 'profile.txt'
        cProfile.run('main()', profile_filename)
        statsfile = open("profile_stats.txt", "wb")
        p = pstats.Stats(profile_filename, stream=statsfile)
        stats = p.strip_dirs().sort_stats('cumulative')
        stats.print_stats()
        statsfile.close()
        sys.exit(0)
    sys.exit(main())
